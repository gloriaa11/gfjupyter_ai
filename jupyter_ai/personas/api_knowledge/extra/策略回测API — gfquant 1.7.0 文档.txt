
策略回测API
View page source
策略回测API
¶
编写策略需要实现的回测接口
¶
config
(
dict
)
¶
策略运行的参数配置，需要写在一个名为config的dict里。
通用策略回测的配置参数列举如下，其中没有默认值的参数必须要在自定义的config里指定：
参数名称
默认值
参数说明
start_date
回测起始日期
end_date
回测结束日期
benchmark
None
基准指数代码, 如‘000300.SH’, 默认可以选择INDEX_RETURN因子中的任意基准代码
user_bench
None
自定义基准的因子名称(如user_bench=’DAILY_RETURN’, benchmark=‘600519.SH’)
buy_rate
0
买入费用(手续费/滑点/冲击成本..), 如万分之三: 0.0003
sell_rate
0
卖出费用(税/手续费/滑点/冲击成本..), 如千分之一: 0.001
daily_cost
0
每日固定费用(计提管理费/托管费/运营成本..), 如年管理费1% ≈ 0.01/250
init_cash
1e8
策略初始现金金额
nav_start
None
策略净值的开始日期，默认为从start_date开始，可选’auto’(首次调仓日)
n_accounts
1
策略的子账号数，每个子账号的初始现金为 init_cash/n_accounts
int_shares
False
股票数量是否限制为1手的整数倍，可选’floor’, ‘round’, ‘ceil’，如设为True等同于’floor’；
非False会将股票买卖指令限制为100股的整数倍(科创板限制为200的整数倍)，若交易后的剩余股数小于1个整数倍，剩余股数也将一并卖出。
如果设置了本参数，则需要同时调整max_position参数，令 max_position < 1.0 - (buy_rate + sell_rate + daily_cost) - diff
当选择’floor’/’round’，且组合股票数有100个左右或更多时，diff的一个经验值为>=0.001(即0.1%)
当选择’ceil’或者组合股票数较少时，diff可以从0.01开始尝试 (例：考虑初次调仓满仓时，组合中的股票数量大部分向上round时需要的余量)
ignore_noprice
False
交易时是否剔除没有行情的股票
trade_price
‘CLOSE’
回测的成交价格，可选’AVGPRICE’(全天的VWAP均价)
为了令’AVGPRICE’成交更合理，Alpha模型(run_backtest_by_alpha_model)可选用下个交易日调仓，配置: {‘reb_at_next_day’: True}
cash_div_handling
‘to_stock’
现金分红处理，默认是折合为股票（即全收益的方法），可选
‘to_cash’: 保留为现金
‘fall_naturally’: 按指数的自然回落处理 (即丢弃现金分红，不计入资产)
当前的分红处理算法对除权后价格四舍五入到0.01元产生的误差暂未处理。
notebook
True
是否在notebook中显示策略图表
update_frequency
5
刷新notebook中策略图表的间隔(单位是策略日)
log_level
‘INFO’
日志级别，可选’DEBUG’, ‘WARNING’等。如需查看更多策略运行的信息可设为’DEBUG’
config
=
{
'start_date'
:
'20171229'
,
'end_date'
:
'20190531'
,
'benchmark'
:
'000300.SH'
,
'log_level'
:
'DEBUG'
,
}
init
(
bt
)
¶
一个自定义函数，在回测的开始之前运行一次，可以在里面做一些初始化工作 (可选)
参数:
bt
– 当前正在运行的策略回测实例
gfquant.BackTest
返回:
None
# 初始化函数设置一个计数器值并输出一条日志
def
init
(
bt
):
bt
.
user
.
counter
=
0
bt
.
log
.
info
(
'init'
)
run_daily
(
bt
)
¶
一个自定义函数，在策略回测的每个交易日中运行，可以在里面取因子值，生成组合，进行调仓 (必须)
参数:
bt
– 当前正在运行的策略回测实例
gfquant.BackTest
返回:
None
# 该策略函数在沪深300成分股中取Q_EP因子值最大的60只股票(剔除新股/停牌/ST股票)，按照自由流通市值(FFMV)加权；在每月的最后一个交易日调仓。
def
run_daily
(
bt
):
if
bt
.
is_last_tday_in_month
():
fac
=
bt
.
api
.
get_factor_series
(
'Q_EP'
,
bt
.
today
,
neutral
=
True
,
universe
=
'HS300'
,
exclude
=
True
)
select
=
fac
.
dropna
()
.
sort_values
()[
-
60
:]
ref_weight
=
bt
.
api
.
get_factor_series
(
'FFMV'
,
bt
.
today
,
select
.
index
)
weight
=
ref_weight
/
ref_weight
.
sum
()
*
0.99999
bt
.
order_portfolio_weight
(
weight
)
bt
.
user
.
counter
+=
1
bt
.
log
.
info
(
f
'第{bt.user.counter}次调仓'
)
finished
(
bt
)
¶
一个自定义函数，在回测成功结束后运行一次，可以在里面做一些收尾的工作 (可选)
参数:
bt
– 当前正在运行的策略回测实例
gfquant.BackTest
返回:
None
# 结束函数输出一条日志
def
finished
(
bt
):
bt
.
log
.
info
(
f
'finished, 共调仓{bt.user.counter}次'
)
运行策略回测
¶
方法1: 在notebook单元格里使用%%bt
%%
bt
config
=
{
'start_date'
:
'20171229'
,
'end_date'
:
'20190416'
,
'benchmark'
:
'000300.SH'
,
}
def
run_daily
(
bt
):
pass
方法2: 使用run_backtest接口函数
config
=
{
'start_date'
:
'20171229'
,
'end_date'
:
'20190416'
,
'benchmark'
:
'000300.SH'
,
}
def
run_daily
(
bt
):
pass
from
gfquant
import
run_backtest
report
=
run_backtest
(
config
,
init
=
None
,
run_daily
=
run_daily
,
finished
=
None
)
BackTest - 策略回测类的接口
¶
class
gfquant.
BackTest
(
**kwargs
)
¶
Strategy BackTest Executor
用户不需要创建BackTest的实例对象，在init(bt), run_daily(bt)和finished(bt)等策略接口中的
第一个参数
bt
就是用户可以使用的策略对象
api
¶
一个
DataApi
的实例，策略回测可以通过该对象取因子数据、执行因子标准化和组合优化等操作
Raises:
ValueError
– 如果取数时日期参数错误(如取未来数据时)会抛出ValueError异常
实际案例
>>>
bt
.
api
.
get_factor_series
(
'EP'
,
'20180102, 20180201, 20180301'
)
log
¶
策略回测日志，为一个包装后的Python
logging.Logger
对象，其默认日志格式包括了当前回测日期和已运行时间等信息
实际案例
>>>
bt
.
log
.
info
(
f
'1+1={1+1}'
)
>>>
bt
.
log
.
warning
(
f
'今天日期是
{bt.today}
'
)
user
¶
一个用户可设置的
BackTest.UserContext
用户上下文对象，
可以任意设置属性，整个策略回测过程均可以在run_daily等方法中读写它的属性
实际案例
>>>
bt
.
user
.
my_dict
=
{
'a'
:
100
}
>>>
bt
.
user
.
other
=
'This is a test.'
>>>
print
(
bt
.
user
.
my_dict
[
'a'
],
bt
.
user
.
other
)
today
¶
如果回测运行中，则可以获取当前回测日期
datetime.datetime
实际案例
>>>
bt
.
log
.
info
(
f
'今天日期是
{bt.today}
'
)
get_tday
(
offset=0
)
¶
获取相对于当前回测日期的交易日
参数:
offset
(
int
) – 偏移的交易日数(非自然日)，负数表示取之前的日期，正数表示取将来的日期，
0表示取当前回测日期(即
today
)
返回:
交易日
返回类型:
datetime.datetime
n_accounts
¶
回测策略的子账户数
返回:
子账户数
返回类型:
int
get_price
(
windcodes
)
¶
取当前的股票价格(不复权)；默认情况下取到的就是收盘价，如策略指定了”trade_price”参数，则取该参数指定的交易价格作为当前价格。
参数:
windcodes
(
list_like
or
str
) – 股票代码列表，为None则取全市场股票价格
返回:
如windcodes为列表，则返回pd.Series(index为股票代码, values为股票的价格); 如windcodes为一个股票代码，则返回该股票的价格
返回类型:
pd.Series or float
实际案例
>>>
print
(
bt
.
get_price
([
'000001.SZ'
,
'600000.SH'
]))
get_holding
(
windcodes=None
,
account_id=None
)
¶
取策略当前的股票持仓数量
参数:
windcodes
(
list_like
or
str
) – 股票代码列表，为None则取当前全部持仓
account_id
(
None
or
int
) – 子账户ID，None或0为整体账户(所有子账户之和)，1~n为子账户
返回:
如windcodes为列表，则返回pd.Series(index为股票代码, values为股票当前持仓数量); 如windcodes为一个股票代码，则返回该股票持仓数
返回类型:
pd.Series or float
实际案例
>>>
print
(
bt
.
get_holding
())
get_holding_value
(
account_id=None
)
¶
取策略当前的持仓市值之和
参数:
account_id
(
None
or
int
) – 子账户ID，None或0为整体账户(所有子账户之和)，1~n为子账户
返回:
当前持仓股票的市值之和
返回类型:
float
实际案例
>>>
bt
.
log
.
info
(
f
'持仓市值: {bt.get_holding_value():2f}'
)
get_cash
(
account_id=None
)
¶
策略当前的现金
参数:
account_id
(
None
or
int
) – 子账户ID，None或0为整体账户(所有子账户之和)，1~n为子账户
实际案例
>>>
bt
.
log
.
info
(
f
'现金:
{bt.cash:2f}
'
)
get_value
(
account_id=None
)
¶
取策略当前的市值，相当于 bt.cash + bt.get_holding_value()
参数:
account_id
(
None
or
int
) – 子账户ID，None或0为整体账户(所有子账户之和)，1~n为子账户
返回:
当前持仓股票的市值
返回类型:
float
实际案例
>>>
bt
.
log
.
info
(
f
'总市值: {bt.get_value():2f}'
)
is_last_tday_in_week
(
)
¶
当前日期是否为一周中的最后一个交易日
is_last_tday_in_month
(
)
¶
当前日期是否为一个月里的最后一个交易日
is_last_tday_in_year
(
)
¶
当前日期是否为一年里的最后一个交易日
is_first_tday_in_week
(
)
¶
当前日期是否为一周中的第一个交易日
is_first_tday_in_month
(
)
¶
当前日期是否为一个月里的第一个交易日
is_first_tday_in_year
(
)
¶
当前日期是否为一年里的第一个交易日
is_last_tday_in_backtest
(
)
¶
当前回测日期是不是回测区间的最后一日
返回:
True/False
get_holding_weight
(
windcodes=None
,
account_id=None
)
¶
取策略当前的持仓权重
参数:
windcodes
(
list_like
or
str
) – 股票代码列表，为None则取当前全部持仓
account_id
(
None
or
int
) – 子账户ID，None或0为整体账户(所有子账户之和)，1~n为子账户
返回:
如windcodes为列表，则返回pd.Series(index为股票代码, value为股票当前权重); 如windcodes为一个股票代码，则返回该股票权重
返回类型:
pd.Series or float
实际案例
>>>
print
(
bt
.
get_holding_weight
())
order_shares
(
order
,
quantity=None
,
account_id=None
)
¶
按股票数量下单。其中order参数和quantity参数支持以下几种形式，必须对应：
如果order为pd.Series(index为股票代码，value为下单数量)，则quantity必须为None
如果order为多个股票代码的list，则quantity必须为同样长度的数值list
如果order为一个股票代码，则quantity必须为一个数
参数:
order
(
pd.Series
or
list
or
str
) – 下单股票代码
quantity
(
None
or
list
or
float
) – 下单数量，正数为买入，负数为卖出
account_id
(
None
or
int
) – 子账户ID, 当策略有多个子账户时使用1~n指定子账户, 不分子账户时不需要指定(即None或0)
返回:
None
Raises:
ValueError
– 下单参数错误
实际案例
>>>
bt
.
order_shares
(
'600519.SH'
,
1000
)
# 买1000股贵州茅台
>>>
bt
.
order_shares
([
'000001.SZ'
,
'600519.SH'
,
'601318.SH'
],
[
1000
,
1000
,
1000
])
# 3个股票各买1000股
>>>
order
=
pd
.
Series
(
-
300
,
index
=
[
'000001.SZ'
,
'600519.SH'
,
'601318.SH'
])
>>>
bt
.
order_shares
(
order
)
# 3个股票各卖300股
order_weight
(
order
,
weight=None
,
account_id=None
)
¶
按股票权重下单，参数order和weight的合法组合可参考
order_shares
参数:
order
(
pd.Series
or
list
or
str
) – 下单股票代码
weight
(
None
or
list
or
float
) – 下单权重，正数为买入，负数为卖出
account_id
(
int
) – 子账户ID, 当策略有多个子账户时使用1~n指定子账户, 不分子账户时不需要指定(即None或0)
返回:
None
Raises:
ValueError
– 下单参数错误
order_target_shares
(
order
,
target_shares=None
,
account_id=None
)
¶
按股票目标持仓数量下单，参数order和target_shares的合法组合可参考
order_shares
与
order_shares
的不同之处在于target_shares参数是目标持仓数量 (order参数中不包含但当前持仓中有的股票不会卖出)
参数:
order
(
pd.Series
or
list
or
str
) – 下单股票代码
target_shares
(
None
or
list
or
float
) – 目标持仓数量
account_id
(
int
) – 子账户ID, 当策略有多个子账户时使用1~n指定子账户, 不分子账户时不需要指定(即None或0)
返回:
None
Raises:
ValueError
– 下单参数错误
order_target_weight
(
order
,
target_weight=None
,
account_id=None
)
¶
按股票目标权重下单，参数order和target_weight的合法组合可参考
order_shares
与
order_weight
的不同之处在于target_weight参数是目标持仓权重 (order参数中不包含但当前持仓中有的股票不会卖出)
参数:
order
(
pd.Series
or
list
or
str
) – 下单股票代码
target_weight
(
None
or
list
or
float
) – 目标持仓权重
account_id
(
int
) – 子账户ID, 当策略有多个子账户时使用1~n指定子账户, 不分子账户时不需要指定(即None或0)
返回:
None
Raises:
ValueError
– 下单参数错误
order_portfolio_shares
(
order
,
portfolio_shares=None
,
account_id=None
)
¶
按整个组合的股票目标持仓数量下单，参数order和portfolio_shares的合法组合可参考
order_shares
与
order_shares
和
order_target_shares
的不同之处在于portfolio_shares参数是整个组合的目标持仓数量，
order参数中不包含但当前持仓中有的股票，将会全部卖出
参数:
order
(
pd.Series
or
list
or
str
) – 下单股票代码
portfolio_shares
(
None
or
list
or
float
) – 整个组合的目标持仓数量
account_id
(
int
) – 子账户ID, 当策略有多个子账户时使用1~n指定子账户, 不分子账户时不需要指定(即None或0)
返回:
None
Raises:
ValueError
– 下单参数错误
order_portfolio_weight
(
order
,
portfolio_weight=None
,
account_id=None
)
¶
按整个组合的股票目标持仓权重下单，参数order和portfolio_shares的合法组合可参考
order_shares
与
order_weight
和
order_target_weight
的不同之处在于portfolio_weight参数是整个组合的目标持仓权重，
order参数中不包含但当前持仓中有的股票，将会全部卖出
参数:
order
(
pd.Series
or
list
or
str
) – 下单股票代码
portfolio_weight
(
None
or
list
or
float
) – 整个组合的目标持仓权重
account_id
(
int
) – 子账户ID, 当策略有多个子账户时使用1~n指定子账户, 不分子账户时不需要指定(即None或0)
返回:
None
Raises:
ValueError
– 下单参数错误
实际案例
>>>
ep
=
bt
.
api
.
get_factor_series
(
'EP_TTM'
,
bt
.
today
)
# 取EP_TTM因子
>>>
order
=
pd
.
Series
(
1
/
60
,
index
=
ep
.
sort_values
(
ascending
=
False
)[:
60
]
.
index
)
>>>
bt
.
order_portfolio_weight
(
order
)
# 组合整体调仓，取当天ep值最大的60个股票等权配置
Next
Previous
© Copyright 2018-2022, GF Funds 量化投资部
Built with
Sphinx
using a
theme
provided by
Read the Docs
.